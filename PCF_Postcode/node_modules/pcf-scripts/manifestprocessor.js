"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/// <reference path="../../common/typings/controlmanifest.d.ts"/>
const controlmanifest_1 = require("./controlmanifest");
const clonedeep = require('lodash/clonedeep');
const path = require('path');
const fs = require('fs');
const { BUNDLE_NAME, CODE_ELEM_NAME, LIBRARY_ELEM_NAME, BUILD_TOOL_NAME, PATH_TO_PACKAGEJSON } = require('./constants');
class ManifestProcessor {
    constructor(manifestData) {
        this.resourcesMap = {};
        this.nameTracker = {};
        this.processedManifest = clonedeep(manifestData);
        this.nameTracker[BUNDLE_NAME] = 1;
    }
    // rename paths in <code> and <library>.<packaged_library> under <resources>
    // add built-by element as a child of control node
    getProcessedManifest(pathToVersionFile) {
        // this.addBuiltBy(pathToVersionFile ? pathToVersionFile : PATH_TO_PACKAGEJSON);
        this.processResources();
        return {
            processedManifest: new controlmanifest_1.ControlManifest(this.processedManifest),
            resourcesMap: this.resourcesMap
        };
    }
    // rename paths in <code> and <library>.<packaged_library> under <resources>
    processResources() {
        const resources = this.processedManifest.manifest.control.resources;
        Object.keys(resources).forEach(resourceType => {
            if (resourceType === CODE_ELEM_NAME) {
                // the xsd allows more than one <code> element, but our opinionated build will validate
                // there is only one <code> element
                resources[CODE_ELEM_NAME][0].$.path = BUNDLE_NAME;
            }
            else if (resourceType === LIBRARY_ELEM_NAME) {
                resources[LIBRARY_ELEM_NAME].forEach((lib) => {
                    const packagedLibs = lib.packaged_library;
                    packagedLibs.forEach((packagedLib) => {
                        packagedLib.$.path = this.checkLibName(packagedLib.$.path);
                    });
                });
            }
            else {
                resources[resourceType].forEach((resource) => {
                    resource.$.path = this.checkLibName(resource.$.path);
                });
            }
        });
    }
    // add built-by element as a child of control node
    addBuiltBy(pathToVersionFile) {
        const filePath = path.resolve(pathToVersionFile);
        const buildToolVersion = fs.existsSync(filePath) ? require(filePath).version : 'unknown';
        this.processedManifest.manifest.control['built-by'] = {
            $: {
                name: BUILD_TOOL_NAME,
                version: buildToolVersion
            }
        };
    }
    // Check whether a library's file name has collision with any other resources file
    //  - if so returns a new file name otherwise return original name
    //  - updates the resources map to point the original path to the right name
    checkLibName(libPath) {
        const libName = path.basename(libPath);
        if (this.nameTracker[libName]) {
            const ext = path.extname(libName);
            const suffix = this.nameTracker[libName];
            // increment a number as suffix to differentiate files with existing names
            const newName = `${path.basename(libName, ext)}${suffix}${ext}`;
            this.nameTracker[libName]++;
            this.resourcesMap[libPath] = newName;
            return newName;
        }
        else {
            this.nameTracker[libName] = 1;
            this.resourcesMap[libPath] = libName;
            return libName;
        }
    }
}
exports.ManifestProcessor = ManifestProcessor;
