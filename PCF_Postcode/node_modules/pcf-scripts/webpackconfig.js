"use strict";
/// <reference path="./typings/buildconfig.d.ts"/>
Object.defineProperty(exports, "__esModule", { value: true });
const { BUNDLE_NAME, TEMP_NAMESPACE } = require('./constants');
const path = require('path');
// Append a stub to webpack bundle to prevent overwriting global variables
// If different controls are using the same namespace, webpack will keep redeclaring
// the namespace as global variables. As a result, only of one the controls can be called.
// The inserted stub checks whether the namespace already exists and uses a temporary variable
// to hold the control's constructor.
function getNamespaceStub(namespace, constructor) {
    const splitNamespace = namespace.split('.');
    let stub = `\nvar ${splitNamespace[0]} = ${splitNamespace[0]} || {};\n`;
    for (let i = 1; i < splitNamespace.length; i++) {
        const littleStub = `${splitNamespace.slice(0, i + 1).join('.')}`;
        stub += `${littleStub} = ${littleStub} || {};\n`;
    }
    stub = stub + `${namespace}.${constructor} = ${TEMP_NAMESPACE}.${constructor};\n` +
        `${TEMP_NAMESPACE} = undefined;`;
    return stub;
}
exports.getNamespaceStub = getNamespaceStub;
function getWebpackConfig(control, controlOutputDir, buildMode, watchFlag) {
    const entryPoint = path.resolve(control.getControlPath(), control.getCodeRelativePath());
    return {
        // `production` mode will minify, while `development` will optimize for debugging.
        mode: buildMode,
        watch: watchFlag,
        // Tells webpack where to start walking the graph of dependencies
        entry: entryPoint,
        output: {
            // This library value control what global variable the output control is placed in.
            library: TEMP_NAMESPACE,
            pathinfo: true,
            filename: BUNDLE_NAME,
            path: controlOutputDir
        },
        externals: {
            // Avoids bundling for globals that might already be present.
            react: 'React',
            'react-dom': 'ReactDOM'
        },
        resolve: {
            // Tell webpack which extensions to try when it is looking for a file.
            extensions: ['.ts', '.tsx', '.js', '.jsx']
        },
        module: {
            rules: [
                {
                    // Tells webpack how to load files with TS or TSX extensions.
                    test: /\.(ts|tsx)$/,
                    use: [
                        babelLoader,
                        {
                            loader: require.resolve('ts-loader')
                        }
                    ],
                    exclude: /node_modules/
                },
                {
                    // Tell webpack how to handle JS or JSX files
                    test: /\.(js|jsx)$/,
                    use: [babelLoader]
                }
            ]
        }
    };
}
exports.getWebpackConfig = getWebpackConfig;
/* tslint:disable:align */
// Some babel plugins to support modern JS and TypeScript.
const babelPlugins = [
    [require.resolve('@babel/plugin-proposal-decorators'), { legacy: true }],
    require.resolve('@babel/plugin-proposal-class-properties'),
    require.resolve('@babel/plugin-proposal-object-rest-spread'),
    require.resolve('@babel/plugin-syntax-dynamic-import')
];
// Config for babel to tell it about which browsers we are targeting.
const babelPresetEnv = [
    require.resolve('@babel/preset-env'), {
        targets: {
            esmodules: true
        }
    }
];
const babelLoader = {
    loader: require.resolve('babel-loader'),
    options: {
        sourceType: 'unambiguous',
        presets: [
            babelPresetEnv,
            [require.resolve('@babel/preset-react')]
        ],
        plugins: babelPlugins
    }
};
/* tslint:enable:align */
